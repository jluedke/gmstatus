#!/usr/bin/env python
import gevent.monkey
gevent.monkey.patch_all()

import optparse
import re
import time
import socket

class GearmanClusterStatus(object):
    """collection of GearmanServerStatus"""
    def __init__(self, servers, workers=None, options=None):
        self.servers = servers
        self.workers = workers # workers to watch
        self.cluster_workers = {}
        self.options = options
        self.server_status = {}
        for server in self.servers:
            (host, port) = server.split(':')
            self.server_status[server] = GearmanServerStatus(host, int(port), options)

    def update(self):
        self.cluster_workers.clear()
        threads = []
        for server, status in self.server_status.iteritems():
            threads.append(gevent.spawn(status.update))
        gevent.joinall(threads)

        for server,status in self.server_status.iteritems():
            for worker in status.workers:
                if worker.name not in self.cluster_workers:
                    self.cluster_workers[worker.name] = GearmanClusterWorkerStatus(worker.name)

                # summ up the workers
                self.cluster_workers[worker.name].jobs_queued += worker.jobs_queued
                self.cluster_workers[worker.name].jobs_running += worker.jobs_running
                self.cluster_workers[worker.name].workers_running += worker.workers_running
                self.cluster_workers[worker.name].server_count += 1;

    def __repr__(self):
        result = ''
        self.update()
        for server in self.servers:
            result += 'host: %s\tw: %s\n' % (server, len(self.server_status[server].workers))
            if options.detailed:
                result += str(self.server_status[server])

        result += '-' * 72
        result += "\n";
        for worker in self.cluster_workers:
            result += '%s\n' % self.cluster_workers[worker]

        return result
        
class GearmanServerStatus(object):
    def __init__(self, host, port=4730, options=None):
        self.host = host
        self.port = port
        self.workers = list()
       
    def update(self):
        """connects to and issues a stats command to gearmand"""
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((self.host, self.port))
        fs = s.makefile('wb+')

        # remove any previous run data
        del(self.workers[:])

        while True:
            fs.write('status\n');
            fs.flush()

            line = fs.readline()
            if line == '.\n':
                break

            status = GearmanWorkerStatus(line, options)

            if not options.workers or status.name in options.workers:  
                self.workers.append(status)

        fs.close()
        s.close()

    def __repr__(self):
        result = ''
        for worker in self.workers:
           result += '%s\n' % worker
        return result

class GearmanWorkerStatus(object):
    """Status returned by gearmand"""

    def __init__(self, status_line, options=None):
        self.name = ''
        self.workers_running = 0
        self.jobs_queued = 0
        self.jobs_running = 0
        self.process_status_line(status_line)

    def process_status_line(self, status_line):
        """parse gearman status line"""

        result = re.match('^([a-z0-9A-Z_]+)\s+(\d+)\s+(\d+)\s+(\d+)', 
            status_line
        )
        if (result.group):
            self.name = result.group(1)
            self.jobs_queued = int(result.group(2))
            self.jobs_running = int(result.group(3))
            self.workers_running = int(result.group(4))
        else:
            raise GearmanWorkerStatusLineError(
                "wtf bro bad status - '%s'" % status_line)

    def __repr__(self):
        return "\tq: %d\tr: %d\tw: %d\tworker: %s" % (
            self.jobs_queued, 
            self.jobs_running, 
            self.workers_running,
            self.name 
        )

class GearmanWorkerStatusLineError(Exception):
    pass

class GearmanClusterWorkerStatus(GearmanWorkerStatus):
    def __init__(self, worker):
        self.name = worker
        self.jobs_queued = 0
        self.jobs_running = 0
        self.workers_running = 0
        self.server_count = 0 # number of servers job is running on

    def update(self, jobs_queued, jobs_running, workers_running):
        self.jobs_queued += jobs_queued
        self.jobs_running += jobs_running
        self.workers_running += workers_running
        self.server_count += 1

    def __repr__(self):
        return "s: %d\tq: %d\tr: %d\tw: %d\tworker: %s" % (
            self.server_count, 
            self.jobs_queued, 
            self.jobs_running, 
            self.workers_running,
            self.name)



if __name__ == '__main__':
    parser = optparse.OptionParser()

    parser.add_option("-i", "--interval", metavar="NUMBER", type="int", 
        help="workers to display, can give multiple options")

    parser.add_option("-w", "--workers", action='append', default=[],
        help="workers to display, can give multiple options")

    parser.add_option("-d", "--detailed", action="store_true", default=False,
        help="display detailed results for each server")

    (options, args) = parser.parse_args()

    print options

    # todo: servers = args or read from rc file
    servers = args
    workers = options.workers
    if len(workers) == 0:
        workers = None

    cluster = GearmanClusterStatus(servers, workers, options)

    while True:
        if options.interval:
            time.sleep(options.interval)
        print cluster
        if not options.interval:
            break
